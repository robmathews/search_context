search_context
============

Maintain a trigram index of valid search terms associated with a model, plus other useful tidbits from the postgres tsearch+trigram world.


## To install: 

Generate a context (default is in the table search_terms, but you have have multiple contexts if needed.) A context can be shared between several different models.

```bash
rails g search_context
```

This will create the search_terms model and migrations to install the pg_trigram extension (if needed), create the model table, and create trigram index on the model. The index type is 'gin', if you need a 'gist' index, edit the migration before running it.

Or run it again with a context name if you need to create multiple search contexts.
```bash
rails g search_context some_other_search_terms
```

There are basically two ways that the contents of a search_context can be managed: 

1. dynamically
2. statically

In the dynamic option, every model that uses the search_context contributes terms to it, adding the terms as they are created, removing them as they are deleted. The search_context keeps a count column, and removes terms that have reached a count of zero. An example of this would be a list of names, where the names are created on the fly by the tables using this search context

In contrast, the static option implements a lookup table with fuzzy search. In the static option, the search_context has been populated from some other source. There is no "count" column, and models using this context do not update the search_context on save. An example of this would be a list of countries in the world. You want to be able to search this and check for misspellings, but not so much delete a country if it isn't currently being used in the system.

### dynamic

* Specify --dynamic when generating the search context
* content will be populated automatically

### static

* this is a lookup table
* you need to load the content yourself somehow.

### Options

--dynamic (default false, enables the count column)

## In your model 

```rails
class Author < ActiveRecord::Base
  search_context([:first_name, :last_name], :context=>:search_terms, :granularity=>:broken_by_word)
end
```
context is the name of the table to use, multiple models can share the same table
fields are the database columns to use. Non-database columns are not supported, but you can pass in the name of a method on the class that returns an array of search terms instead of using a list of database columns
granularity is either "broken_by_word" or "complete". This means that we'll either index by each word in the result, or keep them complete. Default is broken_by_word, which usually makes the most sense. Complete might be more useful for book titles ...

## To use

Now you can query the search_terms table for similar words to any given word, for example this would return an active relation consisting of similar first names to 'Charlie'.

    Author.search_terms_mispellings_for(:first_name,'Charlie')
    
Under the covers, this is doing the following:

    Author.join("join search_terms.name % first_name").where('search_terms.name % ?','Charlie')
        
## tsearch

Tsearch is supported by using a dedicated tsvector column on the table. The reasons for this choice is primarily that this approach allows the search document for the model to pull in data from related classes. For example, if you have a Book model, you might want to be to pull the authors name into the search document for the book, so that you could find all books by that author in the same search.

This has a couple of implications:

1. The tsvector can only by maintained by a database trigger, as generating tsvector objects is beyond typical rails types
2. You'll want to customize that trigger in interesting tsearch specific ways, like with different search weights for different columns
3. The tsvector needs an special index on it to perform efficiently

The trigger and the index are generated by typing: 

    rails generate enable_tsearch <table> <context> <col1> <col2> ...
    
Following our example with Author, it would be:

    rails g enable_tsearch authors names first_name last_name

This will generate 3 migrations, which you should review before using:

1. adds a tsvector column call names_vector:tsvector
2. adds a trigger called update_names_vector which calls the stored procedure sp_update_names_vector. You should expect to customize the stored procedure for anything remotely interesting, like pulling in terms from related tables.
3. adds a index on the tsvector column. Depending on your needs, you might need to change the gin index to a gist index. Refer to the postgres docs for the differences.

## Integration with tsearch

This scope can be integrated with the tsearch query like this:
    Author.fuzzy_match('James Blish')

Look in the search context class for the Query module (ie, in search_context.rb in this example) for the implementation of fuzzy_match for your class. This is only an example of what you can do, really you'll be wanting to author something tsearch specific pretty quickly using features like weighting. Therefore this gems approach is only to sketch an outline and provide useful functions and tools for you to extend.

## Generation of scopes in a module for each Context

Since this gem supports reusing the context in several different models, it automatically includes module from the context called 'SearchTerms::Query' which is a place where you can author the scopes that you want to share between the different models.


## Initial rake test to prepopulate all the data

    rake search_terms:populate_context[search_terms,author]
  
Which clears the table and then populates each row from the given fields. On large databases, this task can take some time to complete, hence it is offered in two forms, as raw sql (faster). Of course, that will not work if your generation of search terms requires a join to some other table to get some of the terms. In that case, just use the task as a guide to creating your own.
 
## Customization

### search configuration

The default configuration used in the search is pg.english. Change this by overriding the class method search_config in the search context class, like this

```ruby
class Name
  def self.search_config
    'my_search_configuration'
  end
end
```

Of course, if you do this, you'll need to make a migration that creates the search configuration.

### custom search queries

If you have queries that should be shared between several name contexts, like for example Author and Reader might conceivably use the same Name context for spell correction and searching, then you can place those queries in the Name::Query namespace and they will be included in all classes that use this search context

